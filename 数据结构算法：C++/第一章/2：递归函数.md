## 概述

本章首先讲述递归的基本概念，接着讨论如何从数学上理解递归，最后使用代码实现递归。

### 1.1递归的概念

**递归函数**在被调用之后会调用自己，但是每调用一次自己都会因为输入的参数不同而更靠近最终结果，使得函数在不断的循环调用之中得到结果。

在数学上考虑一个阶乘函数 $f(x) = x!$，其中 $x$ 为整数：
$$
f(x) = \left\{
\begin{array}{ll}
    1, & \text{if } x \leq 1, \\
    xf(x-1),  & \text{else}.
\end{array}
\right.
$$
该函数由两部分组成，第一行公式称之为**基础部分**，该公式是整个函数自己调用自己的最终出口，无论函数调用多少次自己，必然会从该出口结束。第二行公式称为**递归部分**，该公式是整个递归函数每次调用自己的入口，函数调用自己时，每次的输入都会使函数更靠近基础部分。

再考虑斐波那契数列 $f(x) = f(x-1) + f(x-2)$，其中 $x$ 整数：
$$
f(x) = \left\{
\begin{array}{ll}
0, & \text{if } x = 0, \\
1, & \text{else if } x = 1, \\
f(x-1) + f(x-2), & else.
\end{array}
\right.
$$
该函数虽有三行数学公式，但主体仍然由基础部分和递归部分这两个部分组成，其中前两行为基础部分，是函数的最终出口；第三行为递归部分，为递归调用的入口。通俗理解：由于递归需要用到两个入口，因此出口也需要两个。

### 1.2递归与数学归纳

数学上，有一个证明技巧与递归非常相似，称之为数学归纳法。数学归纳法分成两部分，第一部分证明**基础归纳的正确性**，第二部分证明**步骤归纳的正确性**。对于基础归纳，常证明取定义域最小值的情况下**定理的底部正确性**，对于步骤归纳，则证明**定理的连续性**，即使用前一个取值的定理可以推出使用后一个取值的定理。

考虑如下证明，其中 $x$ 为整数：
$$
\sum_{i=0}^x = x(x+1) /2,\ \text{if }x \geq 0.
$$
证明过程如下：

当 $x = 0$ 时，$\sum_{i=0}^x = 0$，基础归纳成立，当 $x \neq 0$ 时，假设在 $x$ 取值为 $x-1$ 的情况下，公式 $(3)$ 成立，即$\sum_{i=0}^{x-1} = (x-1)x /2$ 成立，那么在$x$ 取值为 $x$时，$\sum_{i=0}^x = \sum_{i=0}^{x-1}+ x = (x-1)x /2 + x = x(x+1) /2$ ，步骤归纳成立，由此可以从基础归纳通过步骤归纳逐步推至 $x$ 取无穷都成立。

数学归纳法虽与递归相似，但不是真正的递归，数学归纳法主要用于证明定理，首先证明定理底部是正确性，再证明定理的连续性，最后通过从底部一步步递推来证明整个定理。而递归则用于计算，不适用于证明定理，首先从函数公式的顶层开始计算，接着不断地调用自己进入更深层次，并最终找到出口。

### 1.3 C++递归代码实现

接下来利用C++代码实现公式$(1)$.

```c++
// 程序1.1
int f(int x) {
    if (x <= 1) {
        return 1;
    }

    return f(x - 1);
}
```

该程序接收一个整数值 $x$，每次被调用都会判断本次调用是否为基础部分（即 $x$ 是否小于等于1），如果是基础部分，则从出口结束，否则说明本次调用为递归部分，需要继续调用自身。

