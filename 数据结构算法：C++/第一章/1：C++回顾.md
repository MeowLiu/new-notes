## 概述

本章内容假设你对C++有所了解，主要是回顾与复习，而不是教学，如果你不了解C++请移至别处进行学习。

### 1.1函数与参数

#### 1.1.1传值参数

考察下列求和函数，该函数表示接收两个整形参数，并对其进行求和输出。

```c++
// 程序1.1
int sum(int a, int b) {
	return a + b;
}
```

在该函数的参数列表中，$a$，$b$ 为函数的**形参**，当该函数被调用时，外面传来的实参将会被复制到 $a$ 和 $b$ 中，这种称为**传值参数**，传值过程中，将会调用实参的**拷贝构造函数**，当函数结束时将会调用形参的**析构函数**。

#### 1.1.2函数模板

上述函数把形参的类型固定住，使其仅针对整数类型，通用性不足，引入函数模板就可解决问题。参考下列模板函数。

```c++
// 程序1.2
template <class T>
T sum(T a, T b) {
    return a + b;
}
```

该函数可以接收诸如浮点数等类型，通用性有所拓展。但是上述函数只适合两种类型相同的形参相加，如果想让浮点数和整数相加将会遇到困难（编译器报错），我们对其进行如下修改即可解决问题。

```c++
// 程序1.3
template <class Ta, class Tb>
auto sum(Ta a, Tb b) {
    return a + b;
}
```

上述函数利用两个不同的模板参数分别进行匹配不同的参数类型，在返回时则使用 **$auto$** 关键字进行**类型推导**，使得函数的通用性大大增强。

#### 1.1.3引用参数

在调用函数时，如果总是使用**传值参数**，将会降低程序的运行速度，想象一下，如果有一个一万维的向量需要被传递，为了将该向量传递到函数内，向量元素将被逐个复制，总共复制一万次，当函数结束时，向量元素被逐个销毁，总共销毁一万次。为了提高效率，使用**引用参数**更好，引用参数的写法如下所示。

```c++
// 程序1.4
template <class Ta, class Tb>
auto sum(Ta &a, Tb &b) {
    return a + b;
}
```

该程序在参数名前加上‘&’表示引用参数，当函数被调用时，将不会再对实参进行复制，而是直接在函数内部使用实参的值，函数结束时也不会实参的析构函数。

#### 1.1.4常量引用参数

上面已经说过，在使用引用参数的时候，函数的内部将会直接使用实参的值，那么直接对实参进行操作就有可能无意会改变实参的值，如果我们不希望无意改变实参的值，使用常量引用实参将会是一个好的选择，常量引用参数的写法如下。

```c++
// 程序1.5
template <class Ta, class Tb>
auto sum(const Ta &a, const Tb &b) {
    return a + b;
}
```

在引用前加上 $const$ 可以对引用形参进行约束，这告诉程序，我们不希望传进来的实参被改变，而仅仅用于运算而已。

#### 1.1.5返回值

函数可以返回值，引用，常量引用。前文介绍引用参数的时候，我们希望不修改原来实参的值，而仅仅是进行运算，现在我们希望允许在函数的内部修改实参的值并进行返回，用于对数据的**本源**进行操作。写法如下。

```c++
// 程序1.6
template <class T>
auto &zero_(T &a) {
    a = 0;
    
    return a;
}
```

该函数表示把 $a$ 的值修改为0（在深度学习中，此函数用于初始化人工神经元的阈值）。在编写函数的返回值时，返回类型中加上‘&’表示返回的是引用，在函数被调用时，该实参被传递，在函数结束时，$a$ 将不会被销毁， $a$ 的**生命周期**将贯穿整个函数。

#### 1.1.6函数重载

**函数签名**由函数的返回类型，函数的形参类型，函数的形参个数共同决定。如果想让一个函数名实现多种不同的功能，可定义同名函数，但是函数签名不相同，这称为**函数重载**。函数重载之后，当调用函数时，编译器会将形参与函数签名进行匹配，并自动选择最合适的重载函数进行调用。函数的重载写法如下。

```c++
// 程序1.7
int area(int length, int width) {
    return length * width;
}


float area(float length, float width) {
    return length * width / 2;
}
```

这并不是一个实用的例子，但足够用于复习。该程序的第一个函数用于求边长为整数的矩形的面积，第二个函数用于求边长为小数的三角形的面积，由于函数形参和面积计算公式均不一样，采用函数重载是合适的。

### 1.2异常

#### 1.2.1抛出异常与处理异常

当程序出错的时候，我们希望**捕获**到出错的信息并且提醒自己出了什么错，使用 $try-catch$ 语句就可以做到这一点。考虑一个场景，假设我们正在构建一个账户注册系统，并且我们不希望用户的账户名长度大于10，我们可以用如下代码来实现。

```c++
// 程序1.8
void check(std::string username) {
    try {
        if (username.length() > 10) {
            throw "The length of username must be <= 10 !";
        }
    } catch (const char *e) {
        std::cout << e << std::endl;
    }
};
```

上述程序中，在 $try$ 语句内进行函数逻辑的编写，并尝试主动发现错误并**抛出**想要的错误类型（此处为字符串类型），而 $catch$ 语句内则尝试捕获在 $try$ 语句内抛出的错误，并对错误进行处理（此处仅仅是将错误打印出来）。当我们看见我们自己定义的错误类型的时候就可以准确的知道错误发生地点，并及时对其进行修改了。

### 1.3动态内存分配

#### 1.3.1 new操作符

​	$new$ 操作符用于在**堆区**申请一块内存，$new$ 返回的是指向堆区内存的指针，在程序运行时堆区指针永远不会自动销毁，该指针需要手动销毁。考虑如下代码。

```c++
// 程序1.9
int *number = new int(1000);
```

此程序在堆区申请一块内存用于存储整数，除非我们**手动销毁**该指针，否则知道其生命周期将会持续到程序结束。

#### 1.3.2 delete操作符

$delete$ 操作符用于销毁堆区申请的指针，考虑如下代码。

```c++
// 程序2.0
delete number;
```

此程序将会销毁程序1.9申请的整数指针。

### 1.4类

C++支持像 $int$， $char$ 等原生类型，但是在实际使用的时候这些原生类型并不能满足我们的需求，此时我们就可利用C++的**类**来定义自己的数据类型并加以使用。接下来我们可考虑定义一个用户类型，并且为其赋予一些**属性**和**方法**。

```c++
#include <string>

class User {
   public:
    User(std::string username, std::string password)
        : username(username), password(password) {};
    ~User() {};

    std::string get_username() const { return username; };

   private:
    std::string username;
    std::string password;
};
```

此程序自定义了一个用户类型，$public$ 表示外部代码可以调用或访问，$User$ 函数是**构造函数**被规定用于初始化对象，在创建对象的时候自动调用，~$USer$ 则是**析构函数**，用于销毁对象，当生命周期结束时自动调用，如果该函数体内为空，则调用默认的析构函数（C++自动销毁），接着创建了一个名为 $get\_username$ **成员方法**，这个成员方法用于获取该用户的用户名，最后 $private$ 表示外部代码无法访问 $username$ 和 $password$ 两个属性。
